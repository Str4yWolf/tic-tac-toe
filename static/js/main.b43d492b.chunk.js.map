{"version":3,"sources":["GameTile.js","GameGrid.js","App.js","serviceWorker.js","index.js"],"names":["GameTile","id","inputShape","clickCallback","disabled","iconContent","class","className","onClick","GameGrid","VALID_SHAPES","SHAPE1","SHAPE2","SOLUTIONS","INITIAL_TILES","INITIAL_TURN","INITIAL_STATUS","useState","tiles","setTiles","currentTurn","setCurrentTurn","status","setStatus","gameOver","setGameOver","useEffect","onTilesChange","setCheckedTile","checkedTileIndex","updatedTiles","slice","winner","checkForWin","setWinner","changeTurn","currentShapeTiles","getTileIndicesWithShape","some","solution","every","solutionTile","includes","t","shape","map","tile","filter","key","Math","floor","random","length","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"qPAwCeA,G,KArCE,SAAC,GAAiD,IAA/CC,EAA8C,EAA9CA,GAAIC,EAA0C,EAA1CA,WAAYC,EAA8B,EAA9BA,cAAeC,EAAe,EAAfA,SAQ5CC,EAAcH,EADP,uBAAGI,MAAM,kBALA,CACrB,EAAK,oBACL,EAAK,SAGiDJ,IACf,+BA0BtC,OAtBIE,EACM,yBAAKG,UAAU,iBACpBF,GAIAH,EACM,yBAAKK,UAAU,eACrBF,GAIM,yBACPE,UAAU,OACVC,QAAS,kBAAML,EAAcF,KAE3BI,KCsGMI,EAjIE,WACf,IAAMC,EAAe,CAAC,IAAK,KACrBC,EAASD,EAAa,GACtBE,EAASF,EAAa,GAEtBG,EAAY,CACE,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GACrB,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,GACrB,CAAC,EAAE,EAAE,GAAG,CAAC,EAAE,EAAE,IAG3BC,EAAgB,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,IACzCC,EAAeJ,EACfK,EAAc,8BAA2BD,EAA3B,YAbC,EAkBKE,mBAASH,GAlBd,mBAkBdI,EAlBc,KAkBPC,EAlBO,OAmBiBF,mBAASF,GAnB1B,mBAmBdK,EAnBc,KAmBDC,EAnBC,OAoBOJ,mBAASD,GApBhB,mBAoBdM,EApBc,KAoBNC,EApBM,OAqBWN,oBAAS,GArBpB,mBAqBdO,EArBc,KAqBJC,EArBI,KAyBrBC,qBAAU,WACJR,IAAUJ,GAAea,MAC5B,CAACT,IAKJ,IAAMU,EAAiB,SAAAC,GACrB,GAAgC,KAA5BX,EAAMW,GAA0B,OAAON,EAlBhB,8CAoB3B,IAAIO,EAAeZ,EAAMa,QACzBD,EAAaD,GAAoBT,EACjCD,EAASW,IAILH,EAAgB,WACpB,IAAIK,EAASC,IACTD,GACFE,EAAUF,GACVP,GAAY,IAEZU,KAKEA,EAAa,WACjBd,EAAeD,IAAgBT,EAASC,EAASD,GACjDY,EAAU,KAINU,EAAc,WAClB,IAAIG,EAAoBC,EAAwBjB,GAEhD,OAAIP,EAAUyB,MAAK,SAAAC,GACjB,OAAOA,EAASC,OAAM,SAAAC,GACpB,OAAOL,EAAkBM,SAASD,SAG7BrB,EACEF,EAAMsB,OAAM,SAAAG,GAAC,MAAU,KAANA,KACnB,YAEA,IAILT,EAAY,SAAAF,GACZtB,EAAagC,SAASV,GACxBT,EAAU,iBAAD,OAAkBH,EAAlB,OAETG,EAAU,iBAKRc,EAA0B,SAAAO,GAC9B,QAAKlC,EAAagC,SAASE,IAET1B,EAAM2B,KAAI,SAACC,EAAM7C,GAAP,MAAc,CAAC6C,EAAM7C,MACjB8C,QAAO,SAAAD,GAAI,OAAIA,EAAK,KAAOF,KACnBC,KAAI,SAAAC,GAAI,OAAIA,EAAK,OAiB3D,OACE,yBAAKvC,UAAU,kBAEb,2CACA,6CAAmBa,GACnB,qCAAyB,KAAXE,GAAiBA,EAA/B,UAEA,yBAAKhB,MAAM,QACPY,EAAM2B,KAAI,SAACC,EAAME,GACjB,OAAO,kBAAC,EAAD,CACLA,IAAKA,EACL/C,GAAI+C,EACJ9C,WAAY4C,EACZ3C,cAAeyB,EACfxB,SAAUoB,QAKhB,4BAAQhB,QAAS,kBA5BnBW,EAASL,GACTO,EAAeX,EAAauC,KAAKC,MAAMD,KAAKE,SAAWzC,EAAa0C,UACpE7B,EAAUP,QACVS,GAAY,KAyBV,WCpHS4B,EARH,WACV,OACE,yBAAK9C,UAAU,OACb,kBAAC,EAAD,QCKc+C,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAC,GACLC,QAAQD,MAAMA,EAAME,c","file":"static/js/main.b43d492b.chunk.js","sourcesContent":["import React from 'react';\nimport './styles.scss';\n\nconst GameTile = ({ id, inputShape, clickCallback, disabled }) => {\n\n\tconst SHAPE_TO_ICON = {\n\t\t'o': 'panorama_fish_eye',\n\t\t'x': 'clear',\n\t}\n\n\tconst icon = <i class=\"material-icons\">{ SHAPE_TO_ICON[inputShape] }</i>\n\tconst iconContent = inputShape ? icon : <span />;\n\n\n \tlet output;\n  \tif (disabled) {\n  \t\toutput = <div className=\"tile disabled\">\n    \t\t{ iconContent }\n    \t</div>\n\n  \t} else {\n  \t\tif (inputShape) {\n  \t\t\toutput = <div className=\"tile filled\">\n  \t\t\t\t{ iconContent}\n  \t\t\t</div>\n\n  \t\t} else {\n  \t\t\toutput = <div\n\t    \t\tclassName=\"tile\"\n\t    \t\tonClick={() => clickCallback(id)}\n\t    \t\t>\n\t    \t\t{ iconContent }\n\t    \t</div>\n  \t\t}\n  \t}\n  \t\n  \t\n  \treturn  output;\n}\n\nexport default GameTile;\n","import React, { useState, useEffect } from 'react';\nimport './styles.scss';\nimport GameTile from './GameTile';\n\nconst GameGrid = () => {\n  const VALID_SHAPES = ['x', 'o'];\n  const SHAPE1 = VALID_SHAPES[0];\n  const SHAPE2 = VALID_SHAPES[1];\n\n  const SOLUTIONS = [\n                      [0,1,2],[3,4,5],[6,7,8],\n                      [0,3,6],[1,4,7],[2,5,8],\n                      [0,4,8],[2,4,6]\n                    ];\n\n  const INITIAL_TILES = ['','','','','','','','',''];\n  const INITIAL_TURN = SHAPE1;\n  const INITIAL_STATUS =  `Ready to play; it's ${INITIAL_TURN}'s turn.`;\n\n  const INVALID_MOVE_MESSAGE = 'Invalid move. Please click an empty field.';\n\n  \n  const [tiles, setTiles] = useState(INITIAL_TILES);\n  const [currentTurn, setCurrentTurn] = useState(INITIAL_TURN);\n  const [status, setStatus] = useState(INITIAL_STATUS);\n  const [gameOver, setGameOver] = useState(false);\n\n\n\n  useEffect(() => {\n    if (tiles !== INITIAL_TILES) onTilesChange();\n  }, [tiles]);\n\n\n\n\n  const setCheckedTile = checkedTileIndex => {\n    if (tiles[checkedTileIndex] !== '') return setStatus(INVALID_MOVE_MESSAGE);\n\n    let updatedTiles = tiles.slice();\n    updatedTiles[checkedTileIndex] = currentTurn;\n    setTiles(updatedTiles);\n  } \n\n\n  const onTilesChange = () => {\n    let winner = checkForWin();\n    if (winner) {\n      setWinner(winner);\n      setGameOver(true);\n    } else {\n      changeTurn();\n    }\n  }\n\n\n  const changeTurn = () => {\n    setCurrentTurn(currentTurn === SHAPE1 ? SHAPE2 : SHAPE1);\n    setStatus('');\n  }\n\n\n  const checkForWin = () => {\n    let currentShapeTiles = getTileIndicesWithShape(currentTurn);\n\n    if (SOLUTIONS.some(solution => {\n      return solution.every(solutionTile => {\n        return currentShapeTiles.includes(solutionTile);\n      })\n    })) {\n      return currentTurn;\n    } else if (tiles.every(t => t !== '')) {\n      return 'no winner';\n    } else {\n      return '';\n    }\n  }\n\n  const setWinner = winner => {\n    if (VALID_SHAPES.includes(winner)) {\n      setStatus(`The winner is ${currentTurn} !`);\n    } else {\n      setStatus('It\\'s a draw.');\n    }\n  }\n\n\n  const getTileIndicesWithShape = shape => {\n    if (!VALID_SHAPES.includes(shape)) return false;\n\n    let tilesWithId = tiles.map((tile, id) => [tile, id]);\n    let filteredTiles = tilesWithId.filter(tile => tile[0] === shape);\n    let filteredTileIndices = filteredTiles.map(tile => tile[1]);\n\n    return filteredTileIndices;\n  }\n\n\n\n  const resetGame = () => {\n    setTiles(INITIAL_TILES);\n    setCurrentTurn(VALID_SHAPES[Math.floor(Math.random() * VALID_SHAPES.length)]);\n    setStatus(INITIAL_STATUS);\n    setGameOver(false);\n  }\n\n\n\n\n  return (\n    <div className=\"game-container\">\n\n      <h2>Tic Tac Toe</h2>\n      <h5>Current Turn: {currentTurn}</h5>\n      <h5> &nbsp; { status !== '' && status } &nbsp; </h5>\n\n      <div class=\"grid\">\n        { tiles.map((tile, key) => {\n          return <GameTile\n            key={key}\n            id={key}\n            inputShape={tile}\n            clickCallback={setCheckedTile}\n            disabled={gameOver}\n          /> \n        }) }\n      </div>\n\n      <button onClick={() => resetGame()}>Reset</button>\n    </div>\n  );\n}\n\nexport default GameGrid;\n","import React from 'react';\nimport GameGrid from './GameGrid';\nimport './styles.scss';\n\nconst App = () => {\n  return (\n    <div className=\"App\">\n      <GameGrid />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}